\section{Keywords and Shorthand
Operators}\label{keywords-and-shorthand-operators}

\subsection{Shorthand Operators}\label{shorthand-operators}

These are concise notations of slightly longer expressions as shown here

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Long expression & Shorthand notation \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{a\ =\ a\ +\ e} & \texttt{a\ +=\ e} \\
\texttt{a\ =\ a\ -\ e} & \texttt{a\ -=\ e} \\
\texttt{a\ =\ a*e} & \texttt{a\ *=\ e} \\
\texttt{a\ =\ a/e} & \texttt{a\ /=\ e} \\
\texttt{a\ =\ a\%e} & \texttt{a\ \%=\ e} \\
\texttt{a\ =\ a\textbackslash{}\textbar{}e} &
\texttt{a\ \textbackslash{}\textbar{}=\ e} \\
\texttt{a\ =\ a\&e} & \texttt{a\ \&=\ e} \\
\texttt{a\ =\ a\^{}e} & \texttt{a\ \^{}=\ e} \\
\end{longtable}

Basically it consists on simplifying the expression of increments and
decrements, where the result of the expression the value of a after the
increment or decrement has been performed.

\subsection{Delete}\label{delete}

The \texttt{delete} keyword that can be used within smart contracts to
reclaim the underlying storage of a variable when it is no longer
required in in that context of the contract. Applying this keyword on a
variable \texttt{a}, of a particular type, assigns the initial value for
that type to \texttt{a}.

So if it is applied on integers, then the value of that variable is set
to 0, for arrays it assigns a length of 0. For dynamic arrays and for
static arrays the length remains the same but all the elements are set
to their initial value.

\texttt{delete\ A{[}x{]}} where \texttt{A} is an array and \texttt{x}
specifies a particular index, deletes the item at that index of that
array and leaves all the other elements and even the length of that
array intact.

For structs, \texttt{delete} assigns a \texttt{struct} with all the
members reset to their initial values. Delete has no effect on mappings,
this is an exception that has to be paid attention to. So if you
\texttt{delete} a struct which in turn has a mapping as one of its
fields, then \texttt{delete} will reset all the members of that struct
that are not mappings and will also recurse into each of those members
unless they are mappings. But if you want to \texttt{delete} a
particular \texttt{key} of that \texttt{mapping} then that is possible.

\subsection{Reserved Keywords}\label{reserved-keywords}

These are keywords in \texttt{Solidity} that are reserved for future
use, so they are not currently used by any of the syntax that is
supported. These may be used for any anticipated new syntactic features
within \texttt{Solidity}.

There are many such reserved keywords, some of them are: \texttt{after},
\texttt{alias}, \texttt{apply}, \texttt{auto}, \texttt{case},
\texttt{null}, etc\ldots{}

You can imagine why these could potentially be reserved: because they
all have a specific significance in the context of programming languages
(especially object-oriented programming languages). \texttt{Solidity}
anticipates that it may support features that may end up using these
reserved keywords.

An example of a keyword that was reserved earlier is \texttt{unchecked},
which is now used as of version \texttt{0.8.0} for declaring any block
within \texttt{Solidity} as being unchecked for arithmetic overflow and
underflow checks. So we can assume that some of these reserved keywords
might be supported in future \texttt{Solidity} versions for different
features.
